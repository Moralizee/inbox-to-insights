
===== C:\Users\adrya\inbox-to-insights\backend\db.py =====

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite:///./emails.db"

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

===== C:\Users\adrya\inbox-to-insights\backend\main.py =====

from fastapi import FastAPI, UploadFile, File, Depends
from fastapi.middleware.cors import CORSMiddleware

import email
from email import policy
from email.utils import parseaddr

import re
from urllib.parse import urlparse
from typing import Optional, List, cast

from sqlalchemy.orm import Session
from sqlalchemy import and_

from db import SessionLocal
from models import Email, EmailLink


app = FastAPI()


# ---------- CORS ----------
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://127.0.0.1:3000",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ---------- DB Session Dependency ----------
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@app.get("/health")
def health():
    return {"status": "ok"}


@app.get("/ping")
def ping():
    return {"message": "pong"}


# ======================================================
#  LIST EMAILS + FILTERS
# ======================================================
@app.get("/emails")
def list_emails(
    db: Session = Depends(get_db),

    q: Optional[str] = None,
    category: Optional[str] = None,
    intent: Optional[str] = None,

    min_risk: float = 0.0,
    max_risk: float = 1.0,
):
    query = db.query(Email)

    # ðŸ” text search
    if q:
        like = f"%{q}%"
        query = query.filter(
            (Email.subject.ilike(like)) |
            (Email.preview.ilike(like))
        )

    # ðŸ· category filter
    if category:
        query = query.filter(Email.category == category)

    # ðŸŽ¯ intent filter
    if intent:
        query = query.filter(Email.intent == intent)

    # âš  risk window filter
    query = query.filter(
        and_(
            Email.risk_score >= min_risk,
            Email.risk_score <= max_risk
        )
    )

    rows: List[Email] = (
        query
        .order_by(Email.id.desc())
        .limit(200)
        .all()
    )

    return [
        {
            "id": e.id,

            "subject": e.subject,

            "from_name": e.from_name,
            "from_email": e.from_email,

            "sender_domain": e.sender_domain,
            "provider": e.provider,
            "is_noreply": e.is_noreply,

            "category": e.category,
            "intent": e.intent,

            "risk_score": e.risk_score,
            "preview": e.preview,
        }
        for e in rows
    ]


# ======================================================
#  EMAIL DETAIL VIEW
# ======================================================
@app.get("/emails/{email_id}")
def get_email(email_id: int, db: Session = Depends(get_db)):
    email_row = (
        db.query(Email)
        .filter(Email.id == email_id)
        .first()
    )

    if not email_row:
        return {"error": "Email not found"}

    risk_flags_str: Optional[str] = cast(Optional[str], email_row.risk_flags)

    links = [
        {"url": l.url, "domain": l.domain}
        for l in email_row.links
    ]

    return {
        "id": email_row.id,

        "subject": email_row.subject,

        "from_raw": email_row.from_raw,
        "from_name": email_row.from_name,
        "from_email": email_row.from_email,

        "sender_domain": email_row.sender_domain,
        "provider": email_row.provider,
        "is_noreply": email_row.is_noreply,

        "category": email_row.category,
        "intent": email_row.intent,

        "risk_score": email_row.risk_score,
        "risk_flags": (
            risk_flags_str.split("; ")
            if risk_flags_str else []
        ),

        "preview": email_row.preview,
        "body": email_row.body,

        "links": links,
    }


# ======================================================
#  PROVIDER DETECTION
# ======================================================
def infer_provider(domain: str) -> str:
    domain = (domain or "").lower()

    PROVIDER_MAP = {
        "github.com": "GitHub",
        "google.com": "Google",
        "gmail.com": "Gmail",
        "microsoft.com": "Microsoft",
        "outlook.com": "Outlook",
        "paypal.com": "PayPal",
        "apple.com": "Apple",
        "facebookmail.com": "Facebook",
        "amazon.com": "Amazon",
        "quora.com": "Quora",
    }

    if domain in PROVIDER_MAP:
        return PROVIDER_MAP[domain]

    if "." in domain:
        parts = domain.split(".")
        root = ".".join(parts[-2:])
        return PROVIDER_MAP.get(root, root)

    return domain


# ======================================================
#  LINK EXTRACTION
# ======================================================
URL_PATTERN = re.compile(
    r'(https?://[^\s<>"\'\)\]]+)',
    re.IGNORECASE,
)


def extract_links(text: str):
    links = []

    for match in URL_PATTERN.findall(text or ""):
        parsed = urlparse(match)
        domain = parsed.netloc.lower()

        links.append({
            "url": match,
            "domain": domain,
        })

    return links


# ======================================================
#  PREVIEW CLEANER
# ======================================================
def clean_preview_text(text: str) -> str:
    if not text:
        return ""

    text = re.sub(r'https?://\S+', '', text)
    text = re.sub(r'\s+', ' ', text).strip()

    return text


# ======================================================
#  CLASSIFIER (Balanced C Strategy)
# ======================================================
def classify_email(subject: str, body: str):

    text = f"{subject} {body}".lower()

    promo_signals = 0

    PROMO_KEYWORDS = [
        "bonus", "reward", "offer", "special offer",
        "discount", "% off",
        "deal", "sale", "promo", "promotion",
        "free spins", "credits", "win", "exclusive",
        "redeem", "claim", "expires", "limited time",
    ]

    if any(k in text for k in PROMO_KEYWORDS):
        promo_signals += 1

    TRACKING_HINTS = [
        "sendgrid", "mandrill", "mailgun",
        "trk.", "click.", "email.",
        "campaign",
        "unsubscribe",
    ]

    if any(k in text for k in TRACKING_HINTS):
        promo_signals += 1

    if any(x in text for x in [
        "<table", "<html", "<div", "img src=",
        "button",
    ]):
        promo_signals += 1

    # Security alerts
    if any(x in text for x in [
        "security alert", "new sign-in", "unusual activity",
        "suspicious", "login attempt"
    ]):
        return "security_alert", "login_security_notice"

    if any(x in text for x in [
        "allowed access", "granted access", "authorized"
    ]):
        return "security_alert", "account_access_granted"

    # Billing
    if any(x in text for x in [
        "invoice", "payment", "receipt", "billing"
    ]):
        return "billing", "transaction_notification"

    # Newsletter
    if any(x in text for x in [
        "newsletter", "digest", "weekly update"
    ]):
        return "newsletter", "content_digest"

    # Promotion (Balanced C threshold)
    if promo_signals >= 2:
        return "promotion", "marketing_offer"

    return "notification", "generic_update"


# ======================================================
#  RISK SCORING
# ======================================================
def compute_risk(
    provider: Optional[str],
    sender_domain: Optional[str],
    links: list,
    is_noreply: bool,
) -> tuple[float, list[str]]:

    provider = (provider or "").lower()
    sender_domain = (sender_domain or "").lower()

    risk = 0.0
    flags: List[str] = []

    link_domains = {l["domain"] for l in links}

    # Domain mismatch warning
    for d in link_domains:
        if provider and provider not in d and sender_domain not in d:
            risk += 0.25
            flags.append(f"suspicious link: {d}")

    if len(link_domains) > 3:
        risk += 0.20
        flags.append("multiple external domains")

    if is_noreply:
        risk += 0.05
        flags.append("no-reply sender")

    return round(min(risk, 1.0), 2), flags


# ======================================================
#  SAVE EMAIL
# ======================================================
def save_email_to_db(parsed: dict, body_text: str, links: list) -> int:

    db: Session = SessionLocal()

    email_row = Email(
        subject=parsed["subject"],

        from_raw=parsed["from_raw"],
        from_name=parsed["from_name"],
        from_email=parsed["from_email"],

        sender_domain=parsed["sender_domain"],
        provider=parsed["provider"],
        is_noreply=parsed["is_noreply"] or False,

        category=parsed["category"],
        intent=parsed["intent"],

        risk_score=parsed["risk_score"],
        risk_flags="; ".join(parsed["risk_flags"]),

        preview=parsed["preview"],
        body=body_text,
)

    db.add(email_row)
    db.flush()  # assigns ID

    # insert links
    for link in links:
        db.add(EmailLink(
            email_id=email_row.id,
            url=link["url"],
            domain=link["domain"],
        ))

    db.commit()
    db.refresh(email_row)
    db.close()

    return cast(int, email_row.id)


# ======================================================
#  PARSE EMAIL UPLOAD
# ======================================================
@app.post("/parse-email")
async def parse_email(file: UploadFile = File(...)):

    contents = await file.read()
    msg = email.message_from_bytes(contents, policy=policy.default)

    subject = msg["subject"] or ""
    from_raw = msg["from"] or ""

    name, email_addr = parseaddr(from_raw)
    email_addr = email_addr.lower() if email_addr else None
    name = name.strip() if name else None

    sender_domain: Optional[str] = None
    provider: Optional[str] = None
    is_noreply = False

    if email_addr and "@" in email_addr:
        sender_domain = email_addr.split("@")[-1]
        provider = infer_provider(sender_domain)

        noreply_keywords = ["no-reply", "noreply", "do-not-reply"]
        is_noreply = any(k in email_addr for k in noreply_keywords)

    # ---------- extract body ----------
    body = ""
    if msg.is_multipart():
        for part in msg.walk():
            if part.get_content_type() == "text/plain":
                body = part.get_content()
                break
    else:
        body = msg.get_content()

    preview = clean_preview_text(body)[:200]

    links = extract_links(body)

    category, intent = classify_email(subject, body)

    risk_score, risk_flags = compute_risk(
        provider,
        sender_domain,
        links,
        is_noreply,
    )

    parsed = {
        "subject": subject,

        "from_raw": from_raw,
        "from_name": name,
        "from_email": email_addr,

        "sender_domain": sender_domain,
        "provider": provider,
        "is_noreply": is_noreply,

        "links": links,

        "category": category,
        "intent": intent,

        "risk_score": risk_score,
        "risk_flags": risk_flags,

        "preview": preview,
    }

    email_id = save_email_to_db(parsed, body, links)

    parsed["email_id"] = email_id
    return parsed

===== C:\Users\adrya\inbox-to-insights\backend\models.py =====

from sqlalchemy import Column, Integer, String, Float, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from db import Base
from db import engine

Base.metadata.create_all(bind=engine)

class Email(Base):
    __tablename__ = "emails"

    id = Column(Integer, primary_key=True, index=True)

    subject = Column(String)
    from_raw = Column(String)
    from_name = Column(String)
    from_email = Column(String)

    sender_domain = Column(String)
    provider = Column(String)
    is_noreply = Column(Boolean, default=False)

    category = Column(String)
    intent = Column(String)

    risk_score = Column(Float)
    risk_flags = Column(Text)   # stored as comma-separated values

    preview = Column(Text)
    body = Column(Text)

    links = relationship("EmailLink", back_populates="email", cascade="all, delete")


class EmailLink(Base):
    __tablename__ = "email_links"

    id = Column(Integer, primary_key=True)
    email_id = Column(Integer, ForeignKey("emails.id"))

    url = Column(Text)
    domain = Column(String)

    email = relationship("Email", back_populates="links")
